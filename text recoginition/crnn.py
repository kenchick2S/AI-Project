# -*- coding: utf-8 -*-
"""CRNN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LdjHTmxTGuwXjalmgSBKVQJs-OAVHccc
"""

# 資料集，可根據需要增加英文或其它字元
DIGITS = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']

# 分類數量
num_classes = len(DIGITS) + 1     # 資料集字元數+特殊識別符號

# 圖片大小，32 x 256
OUTPUT_SHAPE = (32, 256)

# 學習率
INITIAL_LEARNING_RATE = 1e-3
DECAY_STEPS = 5000
REPORT_STEPS = 100
LEARNING_RATE_DECAY_FACTOR = 0.9
MOMENTUM = 0.9

# LSTM網路層次
num_hidden = 128
num_layers = 2

# 訓練輪次、批量大小
num_epochs = 50000
BATCHES = 10
BATCH_SIZE = 32
TRAIN_SIZE = BATCHES * BATCH_SIZE

# 資料集目錄、模型目錄
data_dir = '/lstm_ctc_data/'
model_dir = '/lstm_ctc_model/'

cnt = 10

!wget http://d.xiazaiziti.com/fonts/a/Arial.ttf

import random
import numpy as np
import cv2
from PIL import Image
from PIL import ImageDraw
from PIL import ImageFont

# 生成椒鹽噪聲
def img_salt_pepper_noise(src,percetage):
    NoiseImg=src
    NoiseNum=int(percetage*src.shape[0]*src.shape[1])
    for i in range(NoiseNum):
        randX=random.randint(0,src.shape[0]-1)
        randY=random.randint(0,src.shape[1]-1)
        if random.randint(0,1)==0:
            NoiseImg[randX,randY]=0
        else:
            NoiseImg[randX,randY]=255
    return NoiseImg

# 隨機生成不定長圖片集
def gen_text(cnt):
    # 設定文字字型和大小
    font_path = '/content/Arial.ttf'
    font_size = 30
    font=ImageFont.truetype(font_path,font_size)

    for i in range(cnt):
        # 隨機生成1到10位的不定長數字
        rnd = random.randint(1, 10)
        text = ''
        for j in range(rnd):
            text = text + DIGITS[random.randint(0, len(DIGITS) - 1)]

# 生成圖片並繪上文字
        img=Image.new("RGB",(256,32))
        draw=ImageDraw.Draw(img)
        draw.text((1,1),text,font=font,fill='white')
        img=np.array(img)
        print(len(img))

# 隨機疊加椒鹽噪聲並儲存影象
        img = img_salt_pepper_noise(img, float(random.randint(1,10)/100.0))
        cv2.imwrite(text + '_' + str(i+1) + '.jpg',img)

import os

os.mkdir('lstm_ctc_data')

gen_text(9990)

# Commented out IPython magic to ensure Python compatibility.
# %cd lstm_ctc_data

img = Image.open('0519_1.jpg')
img.show()

import matplotlib.pyplot as plt
img=Image.open('0519_1.jpg')
plt.imshow(img)

# 序列轉為稀疏矩陣
# 輸入：序列
# 輸出：indices非零座標點，values資料值，shape稀疏矩陣大小
def sparse_tuple_from(sequences, dtype=np.int32):
    indices = []
    values = []

    for n, seq in enumerate(sequences):
        indices.extend(zip([n] * len(seq), range(len(seq))))
        values.extend(seq)

    indices = np.asarray(indices, dtype=np.int64)
    values = np.asarray(values, dtype=dtype)
    shape = np.asarray([len(sequences), np.asarray(indices).max(0)[1] + 1], dtype=np.int64)

    return indices, values, shape

# 稀疏矩陣轉為序列
# 輸入：稀疏矩陣
# 輸出：序列
def decode_sparse_tensor(sparse_tensor):
    decoded_indexes = list()
    current_i = 0
    current_seq = []

    for offset, i_and_index in enumerate(sparse_tensor[0]):
        i = i_and_index[0]
        if i != current_i:
            decoded_indexes.append(current_seq)
            current_i = i
            current_seq = list()
        current_seq.append(offset)
    decoded_indexes.append(current_seq)

    result = []
    for index in decoded_indexes:
        result.append(decode_a_seq(index, sparse_tensor))
    return result

# 序列編碼轉換
def decode_a_seq(indexes, spars_tensor):
    decoded = []
    for m in indexes:
        str = DIGITS[spars_tensor[1][m]]
        decoded.append(str)
    return decoded

# 將檔案和標籤讀到記憶體，減少磁碟IO
def get_file_text_array():
    file_name_array=[]
    text_array=[]

    for parent, dirnames, filenames in os.walk(os.getcwd()):
        file_name_array=filenames

    for f in file_name_array:
        text = f.split('_')[0]
        text_array.append(text)

    return file_name_array,text_array

# 獲取訓練的批量資料
def get_next_batch(file_name_array,text_array,batch_size=64):
    inputs = np.zeros([batch_size, OUTPUT_SHAPE[1], OUTPUT_SHAPE[0]])
    codes = []

# 獲取訓練樣本
    for i in range(batch_size):
        index = random.randint(0, len(file_name_array) - 1)
        image = cv2.imread(file_name_array[index])
        image = cv2.resize(image, (OUTPUT_SHAPE[1], OUTPUT_SHAPE[0]), 3)
        image = cv2.cvtColor(image,cv2.COLOR_RGB2GRAY)
        text = text_array[index]

# 矩陣轉置
        inputs[i, :] = np.transpose(image.reshape((OUTPUT_SHAPE[0], OUTPUT_SHAPE[1])))
        # 標籤轉成列表
        codes.append(list(text))

# 標籤轉成稀疏矩陣
    targets = [np.asarray(i) for i in codes]
    sparse_targets = sparse_tuple_from(targets)
    seq_len = np.ones(inputs.shape[0]) * OUTPUT_SHAPE[1]

    return inputs, sparse_targets, seq_len

def get_train_model():
    # 輸入
    inputs = tf.compat.v1.placeholder(tf.float32, [None, None, OUTPUT_SHAPE[0]]) 

# 稀疏矩陣
    targets = tf.compat.v1.sparse_placeholder(tf.int32)

# 序列長度 [batch_size,]
    seq_len = tf.compat.v1.placeholder(tf.int32, [None])

# 定義LSTM網路
    cell = tf.keras.layers.LSTMCell(num_hidden)
    stack = tf.keras.layers.StackedRNNCells([cell] * num_layers)      # old
    outputs, _ = tf.compat.v1.nn.dynamic_rnn(cell, inputs, seq_len, dtype=tf.float32)
    shape = tf.shape(inputs)
    batch_s, max_timesteps = shape[0], shape[1]

    outputs = tf.reshape(outputs, [-1, num_hidden])
    W = tf.Variable(tf.random.truncated_normal([num_hidden,
                                         num_classes],
                                        stddev=0.1), name="W")
    b = tf.Variable(tf.constant(0., shape=[num_classes]), name="b")
    logits = tf.matmul(outputs, W) + b
    logits = tf.reshape(logits, [batch_s, -1, num_classes])

# 轉置矩陣
    logits = tf.transpose(logits, (1, 0, 2))

    return logits, inputs, targets, seq_len, W, b

# 準確性評估
# 輸入：預測結果序列 decoded_list ,目標序列 test_targets
# 返回：準確率
def report_accuracy(decoded_list, test_targets):
    original_list = decode_sparse_tensor(test_targets)
    detected_list = decode_sparse_tensor(decoded_list)

# 正確數量
    true_numer = 0

# 預測序列與目標序列的維度不一致，說明有些預測失敗，直接返回
    if len(original_list) != len(detected_list):
        print("len(original_list)", len(original_list), "len(detected_list)", len(detected_list),
              " test and detect length desn't match")
        return

# 比較預測序列與結果序列是否一致，並統計準確率        
    print("T/F: original(length) <-------> detectcted(length)")
    for idx, number in enumerate(original_list):
        detect_number = detected_list[idx]
        hit = (number == detect_number)
        print(hit, number, "(", len(number), ") <-------> ", detect_number, "(", len(detect_number), ")")
        if hit:
            true_numer = true_numer + 1
    accuracy = true_numer * 1.0 / len(original_list)
    print("Test Accuracy:", accuracy)

    return accuracy

import tensorflow as tf

def train():
    # 獲取訓練樣本資料
    file_name_array, text_array = get_file_text_array()

# 定義學習率
    global_step = tf.Variable(0, trainable=False)
    learning_rate = tf.compat.v1.train.exponential_decay(INITIAL_LEARNING_RATE,
                                               global_step,
                                               DECAY_STEPS,
                                               LEARNING_RATE_DECAY_FACTOR,
                                               staircase=True)
    # 獲取網路結構
    logits, inputs, targets, seq_len, W, b = get_train_model()

# 設定損失函式
    loss = tf.compat.v1.nn.ctc_loss(labels=targets, inputs=logits, sequence_length=seq_len)
    cost = tf.reduce_mean(loss)

# 設定優化器
    optimizer = tf.compat.v1.train.AdamOptimizer(learning_rate=learning_rate).minimize(loss, global_step=global_step)
    decoded, log_prob = tf.compat.v1.nn.ctc_beam_search_decoder(logits, seq_len, merge_repeated=False)
    acc = tf.reduce_mean(tf.edit_distance(tf.cast(decoded[0], tf.int32), targets))

    init = tf.compat.v1.global_variables_initializer()
    config = tf.compat.v1.ConfigProto()
    config.gpu_options.allow_growth = True

    with tf.compat.v1.Session() as session:
        session.run(init)
        saver = tf.compat.v1.train.Saver(tf.compat.v1.global_variables(), max_to_keep=10)

        for curr_epoch in range(num_epochs):
            train_cost = 0
            train_ler = 0
            for batch in range(BATCHES):
                # 訓練模型
                train_inputs, train_targets, train_seq_len = get_next_batch(file_name_array, text_array, BATCH_SIZE)
                feed = {inputs: train_inputs, targets: train_targets, seq_len: train_seq_len}
                b_loss, b_targets, b_logits, b_seq_len, b_cost, steps, _ = session.run(
                    [loss, targets, logits, seq_len, cost, global_step, optimizer], feed)

# 評估模型
                if steps > 0 and steps % REPORT_STEPS == 0:
                    test_inputs, test_targets, test_seq_len = get_next_batch(file_name_array, text_array, BATCH_SIZE)
                    test_feed = {inputs: test_inputs,targets: test_targets,seq_len: test_seq_len}
                    dd, log_probs, accuracy = session.run([decoded[0], log_prob, acc], test_feed)
                    report_accuracy(dd, test_targets)

# 儲存識別模型
                    save_path = saver.save(session, model_dir + "lstm_ctc_model.ctpk",global_step=steps)

                c = b_cost
                train_cost += c * BATCH_SIZE

                train_cost /= TRAIN_SIZE
            # 計算 loss
                train_inputs, train_targets, train_seq_len = get_next_batch(file_name_array, text_array, BATCH_SIZE)
                val_feed = {inputs: train_inputs,targets: train_targets,seq_len: train_seq_len}
                val_cost, val_ler, lr, steps = session.run([cost, acc, learning_rate, global_step], feed_dict=val_feed)

                log = "Epoch {}/{}, steps = {}, train_cost = {:.3f}, val_cost = {:.3f}"
                print(log.format(curr_epoch + 1, num_epochs, steps, train_cost, val_cost))

# RuntimeError: tf.placeholder() is not compatible with eager execution.
tf.compat.v1.disable_eager_execution()

train()

!git clone https://github.com/GitYCC/crnn-pytorch

!ls

# Commented out IPython magic to ensure Python compatibility.
# %cd crnn-pytorch/

!pip install -r requirements.txt

!python src/predict.py -h



import os
import time
import numpy as np
import tensorflow as tf
from matplotlib.pyplot import imread
#from scipy.misc import imresize, imsave
from tensorflow.contrib import rnn

from data_manager import DataManager
from utils import (
    sparse_tuple_from,
    resize_image,
    label_to_array,
    ground_truth_to_word,
    levenshtein,
)

os.environ["TF_CPP_MIN_LOG_LEVEL"] = "3"


class CRNN(object):
    def __init__(
        self,
        batch_size,
        model_path,
        examples_path,
        max_image_width,
        train_test_ratio,
        restore,
        char_set_string,
        use_trdg,
        language,
    ):
        self.step = 0
        self.CHAR_VECTOR = char_set_string
        self.NUM_CLASSES = len(self.CHAR_VECTOR) + 1

        print("CHAR_VECTOR {}".format(self.CHAR_VECTOR))
        print("NUM_CLASSES {}".format(self.NUM_CLASSES))

        self.model_path = model_path
        self.save_path = os.path.join(model_path, "ckp")

        self.restore = restore

        self.training_name = str(int(time.time()))
        self.session = tf.Session()

        # Building graph
        with self.session.as_default():
            (
                self.inputs,
                self.targets,
                self.seq_len,
                self.logits,
                self.decoded,
                self.optimizer,
                self.acc,
                self.cost,
                self.max_char_count,
                self.init,
            ) = self.crnn(max_image_width)
            self.init.run()

        with self.session.as_default():
            self.saver = tf.train.Saver(tf.global_variables(), max_to_keep=10)
            # Loading last save if needed
            if self.restore:
                print("Restoring")
                ckpt = tf.train.latest_checkpoint(self.model_path)
                if ckpt:
                    print("Checkpoint is valid")
                    self.step = int(ckpt.split("-")[1])
                    self.saver.restore(self.session, ckpt)

        # Creating data_manager
        self.data_manager = DataManager(
            batch_size,
            model_path,
            examples_path,
            max_image_width,
            train_test_ratio,
            self.max_char_count,
            self.CHAR_VECTOR,
            use_trdg,
            language,
        )

    def crnn(self, max_width):
        def BidirectionnalRNN(inputs, seq_len):
            """
                Bidirectionnal LSTM Recurrent Neural Network part
            """

            with tf.variable_scope(None, default_name="bidirectional-rnn-1"):
                # Forward
                lstm_fw_cell_1 = rnn.BasicLSTMCell(256)
                # Backward
                lstm_bw_cell_1 = rnn.BasicLSTMCell(256)

                inter_output, _ = tf.nn.bidirectional_dynamic_rnn(
                    lstm_fw_cell_1, lstm_bw_cell_1, inputs, seq_len, dtype=tf.float32
                )

                inter_output = tf.concat(inter_output, 2)

            with tf.variable_scope(None, default_name="bidirectional-rnn-2"):
                # Forward
                lstm_fw_cell_2 = rnn.BasicLSTMCell(256)
                # Backward
                lstm_bw_cell_2 = rnn.BasicLSTMCell(256)

                outputs, _ = tf.nn.bidirectional_dynamic_rnn(
                    lstm_fw_cell_2,
                    lstm_bw_cell_2,
                    inter_output,
                    seq_len,
                    dtype=tf.float32,
                )

                outputs = tf.concat(outputs, 2)

            return outputs

        def CNN(inputs):
            """
                Convolutionnal Neural Network part
            """

            # 64 / 3 x 3 / 1 / 1
            conv1 = tf.layers.conv2d(
                inputs=inputs,
                filters=64,
                kernel_size=(3, 3),
                padding="same",
                activation=tf.nn.relu,
            )

            # 2 x 2 / 1
            pool1 = tf.layers.max_pooling2d(inputs=conv1, pool_size=[2, 2], strides=2)

            # 128 / 3 x 3 / 1 / 1
            conv2 = tf.layers.conv2d(
                inputs=pool1,
                filters=128,
                kernel_size=(3, 3),
                padding="same",
                activation=tf.nn.relu,
            )

            # 2 x 2 / 1
            pool2 = tf.layers.max_pooling2d(inputs=conv2, pool_size=[2, 2], strides=2)

            # 256 / 3 x 3 / 1 / 1
            conv3 = tf.layers.conv2d(
                inputs=pool2,
                filters=256,
                kernel_size=(3, 3),
                padding="same",
                activation=tf.nn.relu,
            )

            # Batch normalization layer
            bnorm1 = tf.layers.batch_normalization(conv3)

            # 256 / 3 x 3 / 1 / 1
            conv4 = tf.layers.conv2d(
                inputs=bnorm1,
                filters=256,
                kernel_size=(3, 3),
                padding="same",
                activation=tf.nn.relu,
            )

            # 1 x 2 / 1
            pool3 = tf.layers.max_pooling2d(
                inputs=conv4, pool_size=[2, 2], strides=[1, 2], padding="same"
            )

            # 512 / 3 x 3 / 1 / 1
            conv5 = tf.layers.conv2d(
                inputs=pool3,
                filters=512,
                kernel_size=(3, 3),
                padding="same",
                activation=tf.nn.relu,
            )

            # Batch normalization layer
            bnorm2 = tf.layers.batch_normalization(conv5)

            # 512 / 3 x 3 / 1 / 1
            conv6 = tf.layers.conv2d(
                inputs=bnorm2,
                filters=512,
                kernel_size=(3, 3),
                padding="same",
                activation=tf.nn.relu,
            )

            # 1 x 2 / 2
            pool4 = tf.layers.max_pooling2d(
                inputs=conv6, pool_size=[2, 2], strides=[1, 2], padding="same"
            )

            # 512 / 2 x 2 / 1 / 0
            conv7 = tf.layers.conv2d(
                inputs=pool4,
                filters=512,
                kernel_size=(2, 2),
                padding="valid",
                activation=tf.nn.relu,
            )

            return conv7

        batch_size = None
        inputs = tf.placeholder(
            tf.float32, [batch_size, max_width, 32, 1], name="input"
        )

        # Our target output
        targets = tf.sparse_placeholder(tf.int32, name="targets")

        # The length of the sequence
        seq_len = tf.placeholder(tf.int32, [None], name="seq_len")

        cnn_output = CNN(inputs)
        reshaped_cnn_output = tf.squeeze(cnn_output, [2])
        max_char_count = cnn_output.get_shape().as_list()[1]

        crnn_model = BidirectionnalRNN(reshaped_cnn_output, seq_len)

        logits = tf.reshape(crnn_model, [-1, 512])
        W = tf.Variable(
            tf.truncated_normal([512, self.NUM_CLASSES], stddev=0.1), name="W"
        )
        b = tf.Variable(tf.constant(0.0, shape=[self.NUM_CLASSES]), name="b")

        logits = tf.matmul(logits, W) + b
        logits = tf.reshape(
            logits, [tf.shape(cnn_output)[0], max_char_count, self.NUM_CLASSES]
        )

        # Final layer, the output of the BLSTM
        logits = tf.transpose(logits, (1, 0, 2))

        # Loss and cost calculation
        loss = tf.nn.ctc_loss(
            targets, logits, seq_len, ignore_longer_outputs_than_inputs=True
        )

        cost = tf.reduce_mean(loss)

        # Training step
        optimizer = tf.train.AdamOptimizer(learning_rate=0.0001).minimize(cost)

        # The decoded answer
        decoded, log_prob = tf.nn.ctc_beam_search_decoder(
            logits, seq_len, merge_repeated=False
        )
        dense_decoded = tf.sparse_tensor_to_dense(
            decoded[0], default_value=-1, name="dense_decoded"
        )

        # The error rate
        acc = tf.reduce_mean(tf.edit_distance(tf.cast(decoded[0], tf.int32), targets))

        init = tf.global_variables_initializer()

        return (
            inputs,
            targets,
            seq_len,
            logits,
            dense_decoded,
            optimizer,
            acc,
            cost,
            max_char_count,
            init,
        )

    def train(self, iteration_count):
        with self.session.as_default():
            print("Training")
            for i in range(self.step, iteration_count + self.step):
                batch_count = 0
                iter_loss = 0
                for batch_y, batch_dt, batch_x in self.data_manager.train_batches:
                    op, decoded, loss_value, acc = self.session.run(
                        [self.optimizer, self.decoded, self.cost, self.acc],
                        feed_dict={
                            self.inputs: batch_x,
                            self.seq_len: [self.max_char_count]
                            * self.data_manager.batch_size,
                            self.targets: batch_dt,
                        },
                    )

                    if i % 10 == 0:
                        for j in range(2):
                            pred = ground_truth_to_word(decoded[j], self.CHAR_VECTOR)
                            print("{} | {}".format(batch_y[j], pred))
                        print("---- {} | {} ----".format(i, batch_count))

                    iter_loss += loss_value
                    batch_count += 1
                    if batch_count >= 100:
                        break

                self.saver.save(self.session, self.save_path, global_step=self.step)

                self.save_frozen_model("save/frozen.pb")

                print("[{}] Iteration loss: {} Error rate: {}".format(
                    self.step, iter_loss, acc))

                self.step += 1
        return None

    def test(self):
        with self.session.as_default():
            print("Testing")
            for batch_y, _, batch_x in self.data_manager.test_batches:
                decoded = self.session.run(
                    self.decoded,
                    feed_dict={
                        self.inputs: batch_x,
                        self.seq_len: [self.max_char_count]
                        * self.data_manager.batch_size,
                    },
                )

                for i, y in enumerate(batch_y):
                    print(batch_y[i])
                    print(ground_truth_to_word(decoded[i], self.CHAR_VECTOR))
        return None

    def save_frozen_model(
        self,
        path=None,
        optimize=False,
        input_nodes=["input", "seq_len"],
        output_nodes=["dense_decoded"],
    ):
        if not path or len(path) == 0:
            raise ValueError("Save path for frozen model is not specified")

        tf.train.write_graph(
            self.session.graph_def,
            "/".join(path.split("/")[0:-1]),
            path.split("/")[-1] + ".pbtxt",
        )

        # get graph definitions with weights
        output_graph_def = tf.graph_util.convert_variables_to_constants(
            self.session,  # The session is used to retrieve the weights
            self.session.graph.as_graph_def(),  # The graph_def is used to retrieve the nodes
            output_nodes,  # The output node names are used to select the usefull nodes
        )

        # optimize graph
        if optimize:
            output_graph_def = optimize_for_inference_lib.optimize_for_inference(
                output_graph_def, input_nodes, output_nodes, tf.float32.as_datatype_enum
            )

        with open(path, "wb") as f:
            f.write(output_graph_def.SerializeToString())

        return True

